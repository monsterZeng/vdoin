(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{552:function(t,e,s){"use strict";s.r(e);var a=s(15),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"object-relationships"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-relationships"}},[t._v("#")]),t._v(" Object relationships")]),t._v(" "),s("p",[t._v("生活充满了对象之间反复出现的模式、关系和层次。通过探索和理解这些，我们可以深入了解现实生活中的物体是如何行为的，从而增强我们对这些物体的理解。")]),t._v(" "),s("p",[t._v("例如，假设有一天你走在街上，你看到一个亮黄色的物体附着在一个绿色的灌木丛物体上。你可能会认出那个亮黄色的东西是花，而那个绿色灌木状的东西是植物。即使你以前从未见过这种植物，你也知道这些绿色的东西是树叶，收集阳光。你会知道这种花能帮助植物繁殖。你也知道如果你杀了植物，花也会死。")]),t._v(" "),s("p",[t._v("但如果你之前没有接触过这种类型的植物，你怎么能知道这些呢?你知道这一点是因为你理解了植物的抽象概念，并且认识到这个植物就是抽象概念的一个实例。你知道大多数植物都是由叶子(部分)组成的，有些还有花。你知道叶子与阳光相互作用(即使你不知道确切的方式)，而且花的存在依赖于植物。因为你知道所有关于植物的事情，你可以推断出很多关于这种植物的事情。")]),t._v(" "),s("p",[t._v("同样，编程也充满了重复出现的模式、关系和层次结构。特别是当涉及到编程对象时，管理实际对象的相同模式也适用于我们自己创建的编程对象。通过更详细地研究这些，我们可以更好地理解如何提高代码的可重用性，并编写更具可扩展性的类。")]),t._v(" "),s("p",[t._v("在前面的章节中，我们已经探讨了一些关于循环模式的想法:我们已经创建了循环和函数，允许我们多次执行特定的任务。此外，我们还创建了自己的枚举、结构和类来实例化给定类型的对象。")]),t._v(" "),s("p",[t._v("我们还研究了层次结构的一些基本形式，如数组(它允许我们将元素分组成一个更大的结构)和递归(函数调用自身的派生版本)。")]),t._v(" "),s("p",[t._v("然而，我们还没有过多地关注对象之间的关系，特别是与编程相关的关系。")]),t._v(" "),s("h2",{attrs:{id:"relationships-between-objects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#relationships-between-objects"}},[t._v("#")]),t._v(" Relationships between objects")]),t._v(" "),s("p",[t._v("在现实生活中，两个对象可能有许多不同类型的关系，我们使用特定的“关系类型”词汇来描述这些关系。例如:一个正方形的“is-a”形状。汽车“有”方向盘。计算机程序员“使用”键盘。一朵花“依靠”一只蜜蜂来授粉。一个学生是一个班级的“成员”。你的大脑作为你的“一部分”存在(至少，我们可以合理地假设，如果你已经走到这一步的话)。")]),t._v(" "),s("p",[t._v("所有这些关系类型在c++中都有有用的类比。")]),t._v(" "),s("p",[t._v("在这一章中，我们将探讨关系类型“part-of”、“has-a”、“uses-a”、“depend -on”和“member-of”的细微差别，并展示它们如何在c++类的上下文中发挥作用。我们还将探讨几个在其他任何地方都不适合的相关主题。")]),t._v(" "),s("p",[t._v("然后我们将在接下来的两章中通过c++的继承模型和虚函数来探讨“is-a”关系。是的，这是一个大问题。")])])}),[],!1,null,null,null);e.default=n.exports}}]);