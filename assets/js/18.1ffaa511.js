(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{531:function(s,t,a){"use strict";a.r(t);var n=a(15),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"the-stack-and-the-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-stack-and-the-heap"}},[s._v("#")]),s._v(" The stack and the heap")]),s._v(" "),a("p",[s._v("程序使用的内存通常分为几个不同的区域，称为段：")]),s._v(" "),a("ul",[a("li",[s._v("代码段（也称为文本段），已编译的程序位于内存中。该代码段通常是只读的。")]),s._v(" "),a("li",[s._v("bss段（也称为未初始化的数据段），其中存储了零初始化的全局变量和静态变量。")]),s._v(" "),a("li",[s._v("数据段（也称为初始化数据段），用于存储初始化的全局变量和静态变量。")]),s._v(" "),a("li",[s._v("堆，从中分配动态分配的变量。")]),s._v(" "),a("li",[s._v("栈，其中存储了函数参数，局部变量和其他与函数相关的信息。")])]),s._v(" "),a("p",[s._v("在本课程中，我们将主要关注堆和栈，因为这是大多数有趣的事情发生的地方。")]),s._v(" "),a("p",[a("strong",[s._v("The heap segment")])]),s._v(" "),a("p",[s._v("​\t堆段（也称为“自由存储”）用于跟踪动态内存分配的内存。")]),s._v(" "),a("p",[s._v("​\t在C ++中，当您使用new运算符分配内存时，该内存将分配到应用程序的堆段中。")]),s._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ptr is assigned 4 bytes in the heap")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("array "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// array is assigned 40 bytes in the heap")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("​\t该内存的地址由new运算符传递回去，然后可以存储在指针中。您不必担心如何定位和分配给用户可用内存背后的机制。但是，"),a("font",{attrs:{color:"red"}},[s._v("值得一提的是连续的请求内存可能不会导致分配到连续的内存！")])],1),s._v(" "),a("p",[s._v("​\t堆有优点也有缺点：")]),s._v(" "),a("ul",[a("li",[s._v("在堆上分配内存相对较慢。")]),s._v(" "),a("li",[s._v("分配的内存将一直保持分配状态，直到被专门释放（请注意内存泄漏）或应用程序结束（此时操作系统应清除内存）。")]),s._v(" "),a("li",[s._v("动态分配的内存必须通过指针访问。取消引用指针比直接访问变量要慢。")]),s._v(" "),a("li",[s._v("因为堆是很大的内存池，大型数组、结构体和类都能被存储在这里。")])]),s._v(" "),a("p",[a("strong",[s._v("The call stack")])]),s._v(" "),a("p",[s._v("​\t调用栈（通常称为“栈”）扮演着更加有趣的角色。调用栈跟踪从程序开始到当前执行点的所有活动函数（已调用但尚未终止的活动功能），并处理所有功能参数和局部变量的分配。调用栈被实现为栈数据结构。因此，在讨论调用栈如何工作之前，我们需要了解什么是栈数据结构。")]),s._v(" "),a("p",[a("strong",[s._v("The stack data structure")])]),s._v(" "),a("p",[s._v("​\t数据结构是一种用于组织数据以便可以有效使用的编程机制。您已经看到了几种类型的数据结构，例如数组和结构。这两种数据结构都提供了用于以有效方式存储数据和访问该数据的机制。编程中还有许多其他常用的数据结构，其中很多是在标准库中实现的，栈就是其中之一。")]),s._v(" "),a("p",[s._v("​\t考虑自助餐厅中的一堆盘子。因为每块盘子都很重并且堆叠在一起，所以您实际上只能做以下三件事之一：")]),s._v(" "),a("ul",[a("li",[s._v("看最上面餐盘的表面。")]),s._v(" "),a("li",[s._v("从栈上取下最上面的餐盘（如果有，将其暴露在下面）。")]),s._v(" "),a("li",[s._v("将新餐盘放在堆栈顶部（如果存在，则将其藏在下面）。")])]),s._v(" "),a("p",[s._v("在计算机编程中，堆栈是包含多个变量（非常像数组）的容器数据结构。但是，虽然数组使您可以按希望的任何顺序访问和修改元素（称为随机访问），但是堆栈受到的限制更大。可以在堆栈上执行的操作对应于上述三件事：")]),s._v(" "),a("ul",[a("li",[s._v("查看堆栈上的顶层元素（通常通过名为"),a("code",[s._v("top()")]),s._v("的函数完成，但有时也称为"),a("code",[s._v("peek()")]),s._v("）。")]),s._v(" "),a("li",[s._v("从栈中取出顶层元素（通过名为"),a("code",[s._v("pop()")]),s._v("的函数完成）。")]),s._v(" "),a("li",[s._v("将新项目放在栈顶部（通过名为"),a("code",[s._v("push()")]),s._v("的函数完成）。")])]),s._v(" "),a("p",[s._v("​    堆栈是后进先出（LIFO）结构。压入栈的最后一项将是弹出的第一项。如果将新元素放在堆栈顶部，则从堆栈中移出的第一个板将是您最后推入的板。最后，首先。将项目推入堆栈时，堆栈会变大；当弹出项目时，堆栈会变小。")]),s._v(" "),a("p",[a("strong",[s._v("The call stack segment")])]),s._v(" "),a("p",[s._v("​\t"),a("strong",[s._v("调用栈段")]),s._v("保存着用于调用栈的内存。当应用程序启动时，操作系统将main()函数推入调用栈。然后程序开始执行。当遇到函数调用时，函数被压入调用栈。如果当前函数结束时，该函数将从调用堆栈中弹出。因此，通过查看推入调用堆栈的函数，我们可以看到为到达当前执行点而调用的所有函数。")]),s._v(" "),a("p",[s._v("​\t栈本身是一个固定大小的内存地址块。堆栈帧跟踪与一个函数调用相关的所有数据。当我们从调用堆栈弹出一个项目时，我们不必删除内存。我们可以让它被下一个被推入内存的项目覆盖。因为堆栈指针将在内存位置下面，所以我们知道内存位置不在堆栈上。")]),s._v(" "),a("p",[a("strong",[s._v("The call stack in action")])]),s._v(" "),a("p",[s._v("​\t让我们更详细地研究调用栈是如何工作的。以下是调用函数时发生的步骤序列:")]),s._v(" "),a("ul",[a("li",[s._v("程序遇到一个函数调用。")]),s._v(" "),a("li",[s._v("构建一个stack frame并将其推入栈。堆栈帧包括:\n"),a("ul",[a("li",[s._v("函数调用之外的指令地址(称为返回地址)。这就是CPU如何在被调用函数退出后记住返回到哪里。")]),s._v(" "),a("li",[s._v("所有的函数参数。")]),s._v(" "),a("li",[s._v("任何局部变量的内存。")]),s._v(" "),a("li",[s._v("保存了函数修改的任何寄存器的副本，当函数返回时需要恢复。")])])]),s._v(" "),a("li",[s._v("CPU跳转到函数的起始点。")]),s._v(" "),a("li",[s._v("函数内部的指令开始执行。")])]),s._v(" "),a("p",[s._v("​     当函数终止时，会发生以下步骤:")]),s._v(" "),a("ul",[a("li",[s._v("从调用栈中恢复寄存器。")]),s._v(" "),a("li",[s._v("堆栈帧从堆栈中弹出。这样就为所有局部变量和参数释放了内存。")]),s._v(" "),a("li",[s._v("返回值被处理。")]),s._v(" "),a("li",[s._v("CPU在返回地址处继续执行。")])]),s._v(" "),a("p",[s._v("​    根据计算机的体系结构，可以以多种不同的方式处理返回值。一些体系结构将返回值作为堆栈框架的一部分。其他的则使用CPU寄存器。")]),s._v(" "),a("p",[s._v("​\t通常，了解有关调用堆栈如何工作的所有详细信息并不重要。但是，了解函数在调用时会有效地推入栈中，并在函数返回时弹出时会为您提供了解递归所需的基础知识，以及一些其他在调试时有用的概念。")]),s._v(" "),a("p",[s._v("​\t"),a("font",{attrs:{color:"red"}},[s._v("技术要点:在某些架构上，调用堆栈从内存地址0开始增长。在其他情况下，它向内存地址0增长。因此，新推入的堆栈帧可能比前一个堆栈帧有更高或更低的内存地址。")])],1),s._v(" "),a("p",[a("strong",[s._v("A quick and dirty call stack example")])]),s._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// b")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// foo is popped off the call stack here")]),s._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// a")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// foo is pushed on the call stack here")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// c")]),s._v("\n \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("在标记的点上，调用堆栈看起来如下:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("a:\n\tmain()\nb:\n\tfoo() (including parameter x)\n\tmain()\nc:\n\tmain()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[a("strong",[s._v("Stack overflow")])]),s._v(" "),a("p",[s._v("​\t堆栈的大小是有限的，因此只能容纳有限数量的信息。在Windows上，默认的堆栈大小是1MB。在一些unix机器上，它的大小可以达到8MB。如果程序试图在堆栈中放置太多的信息，就会导致堆栈溢出。当堆栈中的所有内存都已分配完时，堆栈溢出就会发生——在这种情况下，进一步的分配将开始溢出到内存的其他部分。")]),s._v(" "),a("p",[s._v("​\t堆栈溢出的结果通常是在堆栈上分配太多的变量,和/或制造太多的嵌套的函数调用(在函数调用函数B调用函数C调用函数D等)在现代操作系统中,堆栈溢出通常会导致您的系统问题和终止程序访问冲突。")]),s._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("​\t在上面的程序中，每次调用"),a("code",[s._v("foo()")]),s._v("时都推入一个栈段，因为"),a("code",[s._v("foo()")]),s._v("不断地调用自己，最终栈会跑出内存导致溢出。")]),s._v(" "),a("p",[s._v("The stack has advantages and disadvantages:")]),s._v(" "),a("ul",[a("li",[s._v("Allocating memory on the stack is comparatively fast.")]),s._v(" "),a("li",[s._v("只要在堆栈上，分配在堆栈上的内存就一直在作用域内。从堆栈中弹出时，它将被销毁。")]),s._v(" "),a("li",[s._v("在编译时就知道堆栈上分配的所有内存。因此，可以通过变量直接访问该内存。")]),s._v(" "),a("li",[s._v("因为堆栈相对较小，所以做任何占用大量堆栈空间的事情通常不是一个好主意。这包括按值传递或创建大型数组或其他内存密集型结构的局部变量。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);